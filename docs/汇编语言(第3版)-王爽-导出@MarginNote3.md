## 汇编语言(第3版)-王爽-导出@MarginNote3

> 在MarginNote3 中做的笔记 Obsidian Bridge 导出，个人整理的，图片缺失，但是可以搜索和查看
> 完整形态是 assets/汇编语言(第3版)-王爽(2022-08-19-20-53-48).marginpkg 和 《汇编语言(第3版)-王爽》.pdf 导入MarginNote3 中，直接跳转查看上下文
> ![mn3跳转展示](../assets/mn3跳转展示.png)
> 半完整形态是打开 assets/汇编语言(第3版)-王爽(2022-08-19-21-04-14).ooutline ，需要的软件是OmniOutliner，可以看到图片还有跳转链接





- 汇编语言(第3版)-王爽 [](marginnote3app://note/1A37CDCD-13AB-46DA-B32B-47B6957E0EF6)
    - 第1章 基础知识 [](marginnote3app://note/CE285469-8D81-4EA5-984B-F2557273DE96)
        - 1.1 机器语言 [](marginnote3app://note/8ECCC471-2985-4BE6-B651-733F02A09736)
        - 1.2 汇编语言的产生 [](marginnote3app://note/1A8027F7-DA60-4212-B5EA-D5B2D06E3BED)
            - 例如：机器指令1000100111011000表示把寄存器BX的内容送到AX中。汇编指令则写成mov ax,bx。这样的写法与人类语言接近，便于阅读和记忆。 操作：寄存器BX的内容送到AX中机器指令：1000100111011000 汇编指令：mov ax,bx [](marginnote3app://note/76AABF8A-DCBF-4BF8-8914-C67403CB3A63)
            - 需要有一个能够将汇編指令转换成机器指令的翻译程序,这样的程序我们称其为**编译器**。程序员用汇编语言写出**源程序**,再用汇编编译器将其编译为**机器码**,由计算机最终执行。 [](marginnote3app://note/D44FFF2A-BF24-49AC-8DF1-87A8F7B109B7)
        - 1.3汇编语言的组成 [](marginnote3app://note/78C6E6F8-F40D-4360-9545-D113F95D0788)
            - (1)汇编指令：机器码的助记符，有对应的机器码。 [](marginnote3app://note/E28BF1D0-7250-4686-A72B-73C2F1D0230C)
            - (2)伪指令：没有对应的机器码，由编译器执行，计算机并不执行。 [](marginnote3app://note/38619777-0F70-405B-8E36-652404688E8A)
            - (3) 其他符号：如+、-、*、/等，由编译器识别，没有对应的机器码。 [](marginnote3app://note/8E07C997-4640-48D5-B74D-30522143F516)
        - 1.7 CPU对存储器的读写 [](marginnote3app://note/7647C7CF-3A7F-4522-A113-0780942FFF88)
            - 存储单元的地址（地址信息）； [](marginnote3app://note/C9E5CD8E-A56E-4957-BAD8-320DDAECE000)
            - 器件的选择，读或写的命令（控制信息）： [](marginnote3app://note/B718949B-2A77-485D-8EA3-998140ADB602)
            - 读或写的数据（数据信息） [](marginnote3app://note/44243B0A-AD9A-44BB-A513-7A091CA5CEF7)
        - 1.8地址总线 [](marginnote3app://note/CD0220BC-2508-44F1-9021-49EA20C502DB)
            - 一个CPU有N根地址线，则可以说这个CPU的地址总线的宽度为N。这样的CPU 最多可以寻找2的N次方个内存单元。 [](marginnote3app://note/4AC7011C-582C-4BD8-8163-B24E0CB52F24)
        - 1.9数据总线 [](marginnote3app://note/419BA591-CC52-40CC-B601-C2F94F9073D5)
            - CPU与内存或其他器件之间的数据传送是通过数据总线来进行的。数据总线的宽度决定了CPU和外界的数据传送速度。8根数据总线一次可传送一个8位二进制数据（即一个字节)。 [](marginnote3app://note/026600F6-64C9-4D05-B12F-B00F3E5C281B)
        - 1.13接口卡 [](marginnote3app://note/E2B548A3-CE0F-4D93-839C-A820CCA90418)
            - 扩展插槽通过总线和CPU相连，所以接口卡也通过总线同CPU相连。CPU可以直接控制这些接口卡，从而实现CPU对外设的间接**控制**。 [](marginnote3app://note/A14BA82D-0F08-4D99-82DA-C6B7E3AF45E2)
        - 1.14各类存储器芯片 [](marginnote3app://note/DD9278A7-815E-4A8C-BB83-8565F914862C)
            - 随机存储器 [](marginnote3app://note/05905CA2-A78E-4889-8959-94EF4607A88E)
            - 装有BIOS(Basic Input/Output System,基本输入/输出系统)的ROM [](marginnote3app://note/49FC4BBE-AA1A-4791-882F-684D771AB1EA)
            - 接口卡上的RAM [](marginnote3app://note/5FC14AB4-9D2A-47DE-8355-4AA07B21EE37)
        - 1.15 内存地址空间 [](marginnote3app://note/064C9ABD-2D11-459C-8FC5-8EAB87B8C200)
            - 内存地址空间(假想的逻辑存储器) RAM(主存储器) ROM(装有系统BIOS) 主存储器CPU 地址空间RAM(主存储器) 内存条总线显存地址空间RAM(显存ROM(装有显卡BIOS 显卡BIOS ROM 显卡地址空间扩展插槽网卡BIOS ROM 地址空间ROM(装有网卡BIOS 系统BIOS ROM 网卡地址空间扩展插槽其他器件 [](marginnote3app://note/F7647914-B539-4DA7-8F55-802AEF375040)
            - 地址07FFFH的32KB空间为主随机存储器的地址空间；  地址8000H9FFFH的8KB空间为显存地址空间；  地址A000H~FFFFH的24KB空间为各个ROM的地址空间。 [](marginnote3app://note/7842134D-E550-4191-BB73-E3F91151BE20)
            - CPU向内存地址为C000H的内存单元中写入数据的操作是没有结果的，**C000H单元中的内容不会被改变**，C000H单元实际上就是**ROM存储器中的一个单元**。 [](marginnote3app://note/FF1588CB-94D8-4C20-A027-30EC0C3FB4A2)
    - 第2章寄存器 [](marginnote3app://note/E0D282F0-D5D8-490E-AE5B-FC5AA8C6A9D4)
        - 2.1通用寄存器 [](marginnote3app://note/AA7FBA6C-D1C4-487F-BC93-112B47CF0A60)
            - 8086CPU的上一代CPU中的寄存器都是8位的，为了保证兼容，使原来基于上代CPU编写的程序稍加修改就可以运行在8086之上，8086CPU的AX、BX、CX、DX这4 个寄存器都可分为两个可独立使用的8位寄存器来用： [](marginnote3app://note/9F63675B-565D-4510-9BB9-CE9AF85E9652)
            - AX的低8位(0位~7位)构成了AL寄存器，高8位(8位~15位)构成了AH寄存器。 AH和AL寄存器是可以独立使用的8位寄存器。图2.4展示了16位寄存器及它所分成的两个8位寄存器的数据存储的情况。 [](marginnote3app://note/BEBDF8EE-5B2A-437A-8EB8-6F5F78629BCD)
        - 2.3几条汇编指令 [](marginnote3app://note/4EEEE346-1FF5-42CE-9D10-7D1DCA29582F)
            - 问题2.2 [](marginnote3app://note/A1E83EED-B005-4234-82BB-5B7BBAF77B96)
                - 程序段中的最后一条指令add al,93H,在执行前，al中的数据为C5H,相加后所得的值为：158H,但是l为8位寄存器，只能存放两位十六进制的数据，所以最高位的1丢失，x中的数据为：0058H。(这里的丢失，指的是进位值不能在8位寄存器中保存，但是CPU并不真的丢弃这个进位值， [](marginnote3app://note/BD16A71D-459F-457C-AD3F-A832B358F95D)
                - 此时al是作为一个**独立的8位寄存器来使用**的，和ah没有关系，CPU在执行这条指令时**认为ah和al是两个不相关的寄存器**。不要错误地认为，诸如add al,.93H的指令**产生的进位会存储在ah中**，**add al,93H进行的是8位运算**。 [](marginnote3app://note/0551A61D-85F7-4CB6-A442-821C590209BF)
        - 2.6 8086CPU给出物理地址的方法 [](marginnote3app://note/57788BFA-801A-43A0-8F34-7D64A311A4CC)
            - 地址加法器采用物理地址=段地址×16+偏移地址的方法用段地址和偏移地址合成物理地址。 [](marginnote3app://note/4521D3E7-4ECD-4F67-AE48-0AB0792853A5)
        - 2.9段寄存器 [](marginnote3app://note/68D05349-7E09-43E0-AB77-162105CED4CD)
            - 8086CPU有4个段寄存器：CS、DS、SS、ES。当8086CPU要访问内存时由这4个段寄存器提供内存单元的段地址。 [](marginnote3app://note/418F47E7-AC2C-416B-B780-D591DEC1364D)
        - 2.10CS和IP [](marginnote3app://note/21B79553-CFF7-4AC3-B8BC-4B4CD3FC0D00)
            - CS和IP是8086CPU中两个最关键的寄存器，它们指示了CPU当前要读取指令的地址。CS为代码段寄存器，P为指令指针寄存器，从名称上我们可以看出它们和指令的关系。 [](marginnote3app://note/8C5A63F7-DC4E-4B57-9D66-1F6ADBB63932)
            - 8086机中，任意时刻，CPU将CS:IP指向的内容当作指令执行。 [](marginnote3app://note/F3E18E9E-9988-4203-9E93-DBC6026D5601)
            - 8086CPU的工作过程可以简要描述 [](marginnote3app://note/97D5B08D-916C-494D-9F25-0B606264DDAF)
        - 2.11 修改CS、IP的指令 [](marginnote3app://note/A18C94EA-B5EC-4ABE-B4F9-8720F0E66F94)
            - 同时修改CS、IP的内容，可用形如“jmp段地址：偏移地址”的指令完成 [](marginnote3app://note/0A941BC6-66A5-4B91-A263-8403850D82DF)
            - jmp某一合法寄存器”指令的功能为：用寄存器中的值修改P [](marginnote3app://note/7D0D8621-8382-4A3C-B111-214F01B2A15E)
        - Debug功能 [](marginnote3app://note/EB69A196-4024-44B8-BEFF-FDFEEC6E3D9C)
    - 第3章寄存器（内存访问） [](marginnote3app://note/C4BB8B19-6A23-4871-9E2F-EC6CE46C8F75)
        - 3.1 内存中字的存储 [](marginnote3app://note/D980FF56-95D9-4474-843F-D59BB642D095)
            - CPU中，用16位寄存器来存储一个字。高8位存放高位字节，低8位存放低位字节。 [](marginnote3app://note/76C4EBD6-A6B4-42E9-B5C5-D0C72F8F63BA)
        - 3.5数据段 [](marginnote3app://note/577D0F94-310B-4A4A-897D-E88C6EC82623)
            - 如何访问数据段中的数据呢？将一段内存当作数据段，是我们在编程时的一种安排，; 可以在具体操作的时候，用ds存放数据段的段地址，再根据需要，用相关指令访问数据段中的具体单元。; 注意“字节”和“字”的长度区分 [](marginnote3app://note/94A295E2-01A0-46BE-9029-E91761AE47C7)
        - 3.6栈 [](marginnote3app://note/4D8001F0-1FB6-4899-B901-BD9CB8197DD7)
            - 栈是一种具有特殊的访问方式的存储空间。 [](marginnote3app://note/38D066C4-8838-476C-A560-89FC0D3A9595)
            - 栈有两个基本的操作：入栈和出栈。入栈就是将一个新的元素放到栈顶，出栈就是从栈顶取出一个元素。栈顶的元素总是最后入栈，需要出栈时，又最先被从栈中取出。栈的这种操作规则被称为：LIFO(Last In First Out,.后进先出)。 [](marginnote3app://note/E01236BD-CCB9-4499-A78D-4DC9D0255214)
        - 3.7 CPU提供的栈机制 [](marginnote3app://note/47192387-71CB-4B27-B6A3-312ACB9AB053)
            - 8086CPU提供入栈和出栈指令，最基本的两个是PUSH(入栈)和POP(出栈)。比如，push ax表示将寄存器ax中的数据送入栈中，pop ax表示从栈J顶取出数据送入ax。8086CPU的入栈和出栈操作都是以**字**为单位进行的。 [](marginnote3app://note/543B594B-A537-4BA8-B0F8-C4A382287729)
            - 8086CPU中，有两个寄存器，**段寄存器SS和寄存器SP**,栈顶的段地址存放在SS中，偏移地址存放在SP中。**任意时刻，SS:SP指向栈顶元素**。push指令和pop指令执行时，CPU从SS和SP中得到栈顶的地址。 [](marginnote3app://note/6EFDCAD9-533D-42AE-9521-758E755A884B)
            - push ax的执行，由以下两步完成。(1) **SP-SP-2**,SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶： (2) 将ax中的内容送入SS:SP指向的内存单元处， SS:SP此时指向新栈顶。 [](marginnote3app://note/F4033817-80CE-43F1-BE60-5C656E5B927C)
        - 3.10栈段 [](marginnote3app://note/C5728757-B2B5-4450-9EB0-23DB3AF9BA02)
            - 注意，push,pop等栈操作指令，**修改的只是SP**。也就是说，栈顶的变化范围最大为：O~FFFFH。提供：SS、SP指示栈顶；**改变SP后写内存的入栈指令**；**读内存后改变SP的出栈指 令**。这就是8086CPU提供的栈操作机制。 [](marginnote3app://note/E9E6ACA5-AECC-4E40-BD97-81D9117C46AC)
            - 可见，不管我们如何安排，CPU将内存中的某段内容当作代码，是因CS:P指向了那里；CPU将某段内存当作栈，是因为SS:SP指向了那里。我们一定要清楚，什么是我们的安排，以及如何让CPU按我们的安排行事。要非常清楚CPU的工作机理，才能在控制CPU按照我们的安排运行的时候做到游刃有余。 [](marginnote3app://note/1D6CBA9A-4FEF-4679-8A3C-5BAC2B5B7716)
        - 实验2用机器指令和汇编指令编程 [](marginnote3app://note/06AEFDF1-F29D-46D9-962B-59F27006C026)
            - **中断机制**，它是我们后半部分课程中的一个主题。现在我们只要知道这一点就可以了：**Dbug的T命令在执行修改寄存器SS的指令时，下一条指令也紧接着被执行**。 [](marginnote3app://note/B7BCECDF-B197-480B-BC70-7390311F6E3D)
            - 可能要再做些实验才能发现其中的规律。如果你在这里就正确回答了这个问题，那么要恭喜你，因为你有很好的悟性。大多数的学习者对这个问题还是比较迷惑的，不过不要紧，因为随着课程的进行，这个问题的答案将逐渐变得显而易见。 [](marginnote3app://note/0E7282E6-777A-481D-BF3E-E682FD217519)
                - 线临时桃愧豆一七指发&的林的. 护行七做更处径做所馆6单秀u明，感冷作6盛治飞发择格时保存2生f试厚中死的匹开应个伦里矣不爱6 [](marginnote3app://note/2CE9399A-C942-4141-B645-4AFCA55E44E9)
    - 第4章第一个程序 [](marginnote3app://note/94187ECB-8012-4C83-9CF8-7486A6167D2F)
        - 4.1 一个源程序从写出到执行的过程 [](marginnote3app://note/4AF5BD09-3390-4E59-991C-FF974FCF132A)
            - 第一步：编写汇编源程序。 [](marginnote3app://note/E304C159-D627-4144-903A-0C7F3A740168)
            - 第二步：对源程序进行编译连接 [](marginnote3app://note/BE4E0C13-4D72-45DF-8A33-DA5334EFAD4D)
                - 可执行文件包含两部分内容**程序**（从源程序中的汇编指令翻译过来的机器码)和数据（源程序中定义的数据)**相关的描述信息**（比如，程序有多 大、要占用多少内存空间等) [](marginnote3app://note/F55CE7DF-369C-44F8-B4DB-C5A01EC1ED97)
                - 操作系统**依照可执行文件中的描述信息**，将可执行文件中**的机器码和数据加载入内存**，并进行相关的初始化（比如设置CS:IP指向第一条要执行的指令），然后由CPU执行程序。 [](marginnote3app://note/F7FAE769-94A6-41E9-8530-129F270CFD6A)
        - 4.2源程序 [](marginnote3app://note/6FAE586C-45B6-456E-BFC7-ED9F0A886CF0)
            - 1.伪指令 [](marginnote3app://note/B604B46A-F3D8-4696-BC05-9CDE4E3CC00D)
                - **segment**和**ends**是一对成对使用的伪指令，这是在写可被编译器编译的汇编程序时，必须要用到的一对伪指令。**segment和ends的功能是定义一个段**，segment说明一个段开 始，ends说明一个段结束。一个段必须有一个名称来标识， [](marginnote3app://note/2575A39B-4F8C-4E4A-8F4A-50AC4F21CE4B)
                - **end**是一个汇编程序的结束标记 [](marginnote3app://note/D4CE9468-7072-490E-B290-FE3B37A11F3F)
                - 这条伪指令的含义为“假设”。它假设某一段寄存器和程序中的某一个用segment..ends定义的段相关联。 [](marginnote3app://note/80683C3B-114B-4ABA-A2E4-29D61A3C449A)
                - 在程序的开头，用**assumecs**:**codesg**将用作代码段的**段codesg和CPU中的段寄存器cs联系**起来。 [](marginnote3app://note/131F2FB6-36C2-4AF0-BE77-F7356CFC694B)
            - 用汇编语言写的源程序，包括**伪指令**和**汇编指令**，我们编程的最终目的是让计算机完成一定的任务。源程序中**的汇编指令组成了最终由计算机执行的程序**，而**源程序中的伪指令是由编译器来处理**的，它们并不实现我们编程的最终目的。 [](marginnote3app://note/83FEAF3B-2A9E-4CC9-8A34-35B491503146)
            - 5.程序返回 [](marginnote3app://note/DE29AF93-9088-42F9-AC95-CE0D5BC21CE9)
                - mov ax,4c00H int 21H 这两条指令所实现的功能就是程序返回。 [](marginnote3app://note/F7DC7702-04CB-4847-B8B3-F24DFFA76794)
        - 4.9 程序执行过程的跟踪 [](marginnote3app://note/AB3CBE89-125C-4F5C-9F6B-674E3EE22762)
            - 在这段内存区的前256个字节中，创建一个称为程序段前缀〔SP) 的数据区，03要利用PSP来和被加载程序进行通信 [](marginnote3app://note/8DA2833B-640E-4C22-AD28-17D91D5967D1)
            - 现在，我们可以开始跟踪了，用T命令单步执行程序中的每一条指令，并观察每条指令的执行结果，**到了int21,我们要用P命令执行**， [](marginnote3app://note/AA66C6F5-A858-475D-BA89-D25C2005CC09)
            - 使用Q命令退出Debug,将返回到command中，因为Debug是由command加载运行的。在DOS中用“debug 1.exe”运行Debug对l.exe进行跟踪时，**程序加载的顺序是**：**command加载Debug**,**Debug加载**l.**exe**。返回的顺序是：从l.exe中的程序返回到 Debug,从Debug返回到command.。 [](marginnote3app://note/0380C34D-9497-49CC-831A-850EA352B6EF)
        - 实验3 编程、编译、连接、跟踪 [](marginnote3app://note/D33403A8-90B5-4DE9-A9A1-71EF0768DBB5)
    - 第5章[BX灯]和loop指令 [](marginnote3app://note/E609AA0B-96FA-43CB-B5CD-4A688073B3A9)
        - 5.1[BX] [](marginnote3app://note/BF871487-7075-4290-A3B2-FB8C3D2CEB7D)
            - inc bx的含义是bx中的内容加1 [](marginnote3app://note/B7D69734-AF12-44BC-B137-34D90A2847F4)
        - 5.2LOop指令 [](marginnote3app://note/5884CEDD-7F40-4AB9-9506-64B13979A197)
            - 1) (cx)-(cx)1; [](marginnote3app://note/2E2F4568-0864-4583-9277-1A983E9E47EF)
            - ②判断cx中的值，不为0则转至标号s所标识的地址处执行（这里的指令是add ax,ax),如果为零则执行下一条指令（下一条指令是mov ax,4c00h)。 [](marginnote3app://note/8A5280A2-8ACF-4470-AE15-6066635B47B5)
        - 5.3在Debug中跟踪用Ioop指令实现的循环程序 [](marginnote3app://note/CA9A2FA6-A5A0-4B11-AF2A-81E6C60A1462)
            - 我们知道，大于9FFFh的十六进制数据A000H、A001H..C000H、c001H..FFFEH、FFFFH等，在书写的时候都是以字母开头的。而**在汇编源程序中，数据不能以字母开头**，所以要在前面加0。比如，9138在汇编源程序中可以直接写为“9138h”,而A000h在汇编源程序中要写为“0A000h”。 [](marginnote3app://note/985B8F76-5AA8-465A-925E-8D42409B0663)
            - 这里的问题是，我们希望将循环一次执行完。可以使用p命令来达到目的。再次遇到loop指令时，使用p命令来执行，Debug就会自动重复执行循环中的指令，直到(cx)=O为止。具体情况如图5.14所示。 [](marginnote3app://note/D0084F8A-355E-4033-A4BE-32D1AD9F6860)
            - 当然，也可以用g命令来达到目的，可以用“g0016”直接执行到CS:0016处。具体情况如图5.15所示。 [](marginnote3app://note/1263FA96-8511-4352-B388-1597FDFA6732)
        - 5.5 loop和[bx]的联合应用 [](marginnote3app://note/0DBFCD69-7A4E-4BBB-93BA-DACFE3FCA453)
            - 程序5.6 assume cs:code code segment mov ax,offffh 老电司读、嫁山疾告根动到倒mov ds,ax mov bx,0 :初始化ds:bx指向ffff:0 mov dx,0 初始化累加寄存器dx,(dx)=0 mov cx,12 :初始化循环计数寄存器cx,(cx)=12 S: mov al,[bx] mov ah,0 add dx,ax :间接向dx中加上((ds)*16+(bx))单元的数值inc bx ;ds:bx指向下一个单元loop s mov ax,4c00h int 21h code ends end 在实际编程中，经常会遇到，用同一种方法处理地址连续的内存单元中的数据的问题。我们需要用循环来解决这类问题，同时我们必须能够在每次循环的时候按照同一种方法来改变要访问的内存单元的地址。这时，就不能用常量来给出内存单元的地址（比如， [0]、[1]、[2]中，0、1、2是常量)，而应用变量。“mov al,,[bx]”中的bx就可以看作一个代表内存单元地址的变量，我们可以不写新的指令，仅通过改变bx中的数值，改变指令访问的内存单元。 [](marginnote3app://note/D8F5EC1A-DA51-4987-9139-F3D269FDEDC1)
        - 5.6段前缀 [](marginnote3app://note/D8263EB2-574C-438E-B57F-5894D0ACC6CA)
            - 这些出现在访问内存单元的指令中，用于显式地指明内存单元的段地址的“ds:”“cs:”“ss:”“es:”,在汇编语言中称为段前缀。 [](marginnote3app://note/3812C1DE-E090-4FEA-A521-974AEFCF85B5)
        - 实验4[b]和loop的使用 [](marginnote3app://note/4D95750E-7AE7-426A-A286-4F8A2463005D)
            - (2)编程，向内存0：2000：23F依次传送数据0~63(3FH)，程序中只能使用9条指令，9条指令中包括“mov ax,.4c00h”和“int21h”。 [](marginnote3app://note/227D4053-C128-46E5-8CFC-7A5E5CF83640)
    - 第6章包含多个段的程序 [](marginnote3app://note/B3AE71B8-48FE-44A1-A615-4275B8EE06B9)
        - 6.1 在代码段中使用数据 [](marginnote3app://note/EB710A99-AE80-49B4-A1DB-7013099A062D)
            - 我们用end 指令指明了程序的入口在标号start处，也就是说 [](marginnote3app://note/821C3D4E-4A28-4378-B7C6-BAAA1D6BAC88)
        - 6.2在代码段中使用栈 [](marginnote3app://note/2BCFC1C6-4636-4C09-8A1B-7BB375D1503B)
            - :用dw定义16个字型数据，在程序加载后，将取得16个字的:内存空间，存放这16个数据。在后面的程序中将这段:空间当作栈来使用 [](marginnote3app://note/CE2C25C8-2876-4D96-86A1-E18368CEAC60)
        - 6.3 将数据、代码、栈放入不同的段 [](marginnote3app://note/45F16470-2FC9-40F0-968C-41AE1D222BE4)
            - 段中的数据占N个字节，则程序加载后，该段实际占有的空间 [](marginnote3app://note/AE00D98A-B092-46CF-9202-806755F8ACA2)
    - 第7章更灵活的定位内存地址的方法 [](marginnote3app://note/A1505CB3-846B-4C54-AA36-75BB566A0DF4)
        - 7.1 and和or指令 [](marginnote3app://note/7187F097-D3A2-4750-9911-76CE89E9F760)
            - (2)or指令：逻辑或指令，按位进行或运算。 [](marginnote3app://note/BB6CC468-4881-4A94-9D8C-95DC4D2C57B2)
            - (I)and指令：逻辑与指令，按位进行与运算。 [](marginnote3app://note/2A061714-570B-4AC3-8089-93212EF9EAA7)
        - 7.3 以字符形式给出的数据 [](marginnote3app://note/9033BC3C-9460-49FC-86E2-E898CACF7B42)
        - 7.4大小写转换的问题 [](marginnote3app://note/02833A8E-19BE-4DAC-9331-715883387E05)
            - anda1,11011111B :将a1中的ASCII码的第5位置为0，变为大写字母 [](marginnote3app://note/1048F4EC-4077-4F4D-B92A-A8DEDE082AAC)
        - 7.5 [bx+idata] [](marginnote3app://note/599D12BF-BF94-43F4-A8D8-AE8CE23DD996)
        - 7.7 SI和DI [](marginnote3app://note/C2CB1199-FE18-4374-9BD8-44869FA2F21C)
            - si和di是8086CPU中和bx功能相近的寄存器，si和di不能够分成两个8位寄存器来使用。下面的3组指令实现了相同的功能。 [](marginnote3app://note/B3196668-F914-42FD-A6C8-14675CC8EEB3)
        - 7.8 [bx+si]和[bx+di [](marginnote3app://note/A78AC56E-EEC8-468C-9F7A-99193B542F3A)
        - 7.10 不同的寻址方式的灵活应用 [](marginnote3app://note/7F106AD7-9AC4-4789-987D-60FBE03FDC60)
            - 双重循环 [](marginnote3app://note/606C1A25-31F4-4D78-B7B9-4470C2A9A4AA)
    - 第8章数据处理的两个基本问题 [](marginnote3app://note/A67C1D40-7E23-4256-9600-B472053A0DC1)
        - 为了描述上的简洁，在以后的课程中，我们将使用两个描述性的符号g来表示一个寄存器，用sreg表示一个段寄存器。 [](marginnote3app://note/DF99CF79-1758-45B0-95C9-80C5A1A3EC50)
        - 8.1 bx、si、di和bp [](marginnote3app://note/586D3581-CBE7-4B38-8F5D-B7DEB8DCD252)
        - 8.2 机器指令处理的数据在什么地方 [](marginnote3app://note/3C77689E-CF84-407D-8113-E54B7F6B8B3B)
        - 8.3 汇编语言中数据位置的表达 [](marginnote3app://note/C24DEFFD-910C-4B9B-9E46-A58084B51FE2)
        - 8.4寻址方式 [](marginnote3app://note/80D5ED4F-BDD8-451D-8878-2061F1ADBAD8)
        - 8.5 指令要处理的数据有多长 [](marginnote3app://note/19911EB3-8533-461D-9C14-759734C56F19)
        - 8.6 寻址方式的综合应用 [](marginnote3app://note/549AD380-4866-4E1E-BC91-D71A6C3C99AD)
        - 8.7div指令 [](marginnote3app://note/8E9033BA-4882-4839-A720-69DDF34A7198)
            - 连续进行16除法，需要将DX清空 [](marginnote3app://note/5511A398-EB8F-42E7-A094-D2403B99C933)
            - (1)**除数**：有8位和16位两种，在一个rg或内存单元中。 [](marginnote3app://note/DBBCE6CE-7D3B-4104-A1C1-E09646850221)
            - (2)**被除数**：默认放在AX或DX和AX中，如果除数为8位，被除数则为16位，默认在AX中存放；如果除数为16位，被除数则为32位，在DX和AX中存放，DX存 放高16位，AX存放低16位。 [](marginnote3app://note/9CDCBB0C-ECEA-4A21-B63F-F68F4FCF531D)
            - (3)**结果**：如果除数为8位，则AL存储除法操作的商，AH存储除法操作的余数：如果除数为16位，则AX存储除法操作的商，DX存储除法操作的余数。 [](marginnote3app://note/C1D07CD7-B62E-43EA-BC9F-E9D91682C7D3)
        - 88伪指令dd [](marginnote3app://note/142C45FB-9C0A-427A-B516-E0EE0AF9B31E)
            - mov ax,datamov ds,ax mov ax,ds:[0] ;**ds:0字单元中的低16位存储在ax中** mov dx,ds:[2];**ds:2字单元中的高16位存储在dx中** div word ptr ds:[4];用dx:ax中的32位数据除以ds:4字单元中的数据 mov ds:[6],ax;将商存储在ds:6字单元中 [](marginnote3app://note/F7C57845-C875-45BA-AFA8-2F99BE8DF081)
        - 8.9dup [](marginnote3app://note/08586B97-B520-4441-8EE3-54ECFD778732)
        - 实验7寻址方式在结构化数据访问中的应用 [](marginnote3app://note/6D14621D-165F-40F6-B024-854A1DBCC89E)
    - 数据的结构，组织 [](marginnote3app://note/A8F2C747-76D1-48BC-A7E6-9AC9785DB68F)
    - 第9章转移指令的原理 [](marginnote3app://note/1A67F360-8DA1-4B1F-A997-FD50FA7C50E9)
        - 9.1操作符offset [](marginnote3app://note/9151CCD0-67BC-485C-9363-498A77B5DDD3)
            - 通心粥的元式switch. Mol x,②mo ay,data imp word ptr ds:bx mov 5,0X A尚格比业作钠处理. 叱Oe: mol X,t0片ist ilH mo 0 ay, 像楼M0 ax ,l02oH MpU ds-I0]ax imp over 52、Mwax,IH☑"Mov ax OFFe7 s2 imp over Mov :[2]1以53.m00,lw2H moV 欢，0fe13 jmp over mo0 d4]1X [](marginnote3app://note/7CC0E2ED-0445-453C-B3AF-C8CF38337D88)
        - 9.2jmp指令 [](marginnote3app://note/3B17F07A-1F19-4DF7-A090-E87AC5B4BF18)
        - 9.3 **依据位移进行转移**的jmp指令 [](marginnote3app://note/68501227-83B7-4108-BF73-736264B7FB87)
            - jmp short标号”的功能为：(P)=(IP)+8位位移。 [](marginnote3app://note/212858DA-F190-48BB-959E-6916332371B4)
            - jmp near ptr标号”的功能为：P)=(IP)十l6位位移。 [](marginnote3app://note/D8D7341D-195A-4842-9C6C-6A26252052AB)
        - 9.4 转移的目的地址在指令中的jmp指令 [](marginnote3app://note/C8CA89D9-37F6-4CCA-8FF2-B89D9B0AA43F)
        - 9.5 转移地址在寄存器中的jmp指令 [](marginnote3app://note/44E678F4-B5DD-4F03-BEE6-9A14C4CF503D)
        - 9.6 转移地址在内存中的jmp指令 [](marginnote3app://note/D1157873-7467-46DD-BD82-BFCF68A036D0)
            - (1) jmp word ptr内存单元地址（段内转移） [](marginnote3app://note/E13BCCE5-865C-4AEA-B46E-3671B51C895B)
            - (2)jmp dword ptr内存单元地址（段间转移） [](marginnote3app://note/C82BBA30-1B23-4069-A951-F0DB0D2641E7)
        - 9.7jcXz指令 [](marginnote3app://note/423F90EB-ACA8-47D1-9E12-87DC9B257E69)
            - 指令格式：jcxz标号（如果(cx)一0，转移到标号处执行。） [](marginnote3app://note/AB7932DE-6416-4771-99BD-A5B317FCF19A)
            - 操作：当(cx)=0时，(P)=(P)+8位位移； [](marginnote3app://note/3BD260D1-D3E9-4846-8F5A-62FF879E3BFF)
        - 9.8loop指令 [](marginnote3app://note/CE637553-B9D4-4554-A8E0-11B6B832C3B8)
            - 指令格式：loop标号(cx)(cx)-1,如果(cx)≠0，转移到标号处执行。) [](marginnote3app://note/FF714B0A-DFC1-4488-B0A4-5875E45C9F55)
            - 操作： (1) (cx)=(cx)1; (2) 如果(cx)≠0，(IP)=(P)+8位位移。 [](marginnote3app://note/CD603131-DE70-406D-85EF-B659970B42BA)
        - 实验9根据材料编程 [](marginnote3app://note/AD38E980-BF50-4963-9271-6796693228BF)
    - 第10章CALL和RET指令 [](marginnote3app://note/6F0EF248-4A3E-4C7D-A419-33C84A152322)
        - 10.1 ret和retf [](marginnote3app://note/206AFFC3-485E-45CC-B589-7AC312033A37)
        - 10.3 依据位移进行转移的cal指令 [](marginnote3app://note/8DE1C71E-4C9D-46B0-96BB-6D5D9FE3E1B5)
        - 10.4 转移的目的地址在指令中的call指令 [](marginnote3app://note/8415CC16-58B0-486E-BCE1-6AED84DB123D)
        - 10.7 call和ret的配合使用 [](marginnote3app://note/D63205A6-A444-4D51-91D8-F302DFB9B234)
        - 10.8mul指令 [](marginnote3app://note/08612073-3C24-4DAC-9395-C46105EFAD8D)
        - 10.9模块化程序设计 [](marginnote3app://note/C1989148-529E-48C8-846A-F44839DBD497)
        - 10.10 参数和结果传递的问题 [](marginnote3app://note/8665E575-BBB5-458E-BC66-83D452E8A6DE)
        - 10.11批量数据的传递 [](marginnote3app://note/CEC00F0C-05A1-4E1B-B6C9-0F9CB66AC36D)
        - 10.12 寄存器冲突的问题 [](marginnote3app://note/966CA20B-2CA4-4219-BEAB-80BC7CE850E5)
        - 实验10编写子程序 [](marginnote3app://note/3C7B273D-E326-457C-A17B-6B6476200BB2)
            - 1.显示字符串 [](marginnote3app://note/45FB88E5-F9DB-4D40-B2CC-8BCEB26DD086)
            - 2.解决除法溢出的问题 [](marginnote3app://note/2B24F6BC-985A-437C-AF07-A643D6EB4AC2)
            - 3.数值显示 [](marginnote3app://note/D32B9CA4-B6BA-4FEF-84D2-AF1E87DDFC79)
    - 主要讲了CUP对内存地址空间的使用 [](marginnote3app://note/DB8399C9-2EC9-4940-8150-3F46A08C029D)
    - 第11章 标志寄存器 [](marginnote3app://note/F52CC548-AFAA-411F-8A64-6EACC14081D2)
        - 11.1ZF标志 [](marginnote3app://note/FF0A5724-E3BB-4F2F-8384-B0C95DDC46D6)
        - 11.2PF标志 [](marginnote3app://note/F35102CA-E08E-489C-B2F8-49F8443E89B6)
        - 11.3SF标志 [](marginnote3app://note/09AA7383-F9C3-450D-A2C9-C087B91DAC57)
        - 11.4 CF标志 [](marginnote3app://note/B3370A77-F083-4A53-BDBE-E5007373F56D)
        - 11.5OF标志 [](marginnote3app://note/4DD3BCCA-2448-4128-9EE8-9ADC170973BD)
        - 定要注意CF和OF的区别：CF是对无符号数运算有意义的标志位，而OF是对有符号数运算有意义的标志位。 [](marginnote3app://note/E82C3E25-7918-4128-B65E-24CEB664E1DE)
        - 在8086CPU的指令集中，有的指令的执行是影响标志寄存器的，比如，add、sub、mul、div、inc、or、and等，它们大都是运算指令（进行逻辑或算术运算）；有的指令的执行对标志寄存器没有影响，比如，mov、push、pop等，它们大都是传送指令。在使用一条指令的时候，要注意这条指令的全部功能，其中包括，执行结果对标志寄存器的哪些标志位造成影响。 [](marginnote3app://note/B233DB73-7D0C-4BC5-8C2B-FD90340B842F)
        - 11.6adc指令 [](marginnote3app://note/A17F1676-C874-4ED2-BA8E-824D09CB00E6)
            - 计算分3步进行： (1) 先将低16位相加，完成后，CF中记录本次相加的进位值； (r2) 再将次高16位和C(来自低16位的进位值)相加，完成后，CF中记录本次相加的进位值； (3)最后高16位和CF(来自次高16位的进位值)相加，完成后，CF中记录本次相加的进位值。 [](marginnote3app://note/2D6712EA-5208-4A5D-90E6-DC22F58F0D76)
            - add128:push a ax push cx push si push di sub ax,ax ;将CF设置为0 mov cx,8 s:mov ax,[si] adc ax,[di] mov [si],ax inc sh 为7不号肉.(F张inc si inc di inc di loop s pop di pop si pop CX pop ax ret [](marginnote3app://note/0F4E8596-0A1E-41EA-BDBF-83CFB529E4C1)
        - 11.7sbb指令 [](marginnote3app://note/83C881B6-FAA2-4E23-BA2B-D5FC4D0DA663)
        - 11.8cmp指令 [](marginnote3app://note/4439598F-504F-49EC-9899-12F0B1114E11)
            - 指令cmp ax,ax,做(ax)-(ax)的运算，结果为0，但并不在ax中保存，仅影响f1ag的相关各位。指令执行后：zf1,pf1,sf0,cf0,of0。 [](marginnote3app://note/B84A3044-1A9E-4817-89AE-C2F561AF93D7)
        - 11.9 检测比较结果的条件转移指令 [](marginnote3app://note/FED79E29-127D-4F1A-BA11-4E82525EA52B)
            - 有符号数比较 [](marginnote3app://note/8247E9CA-2284-41F0-B5F3-72D5317FD1F1)
            - 下面是常用的根据无符号数的比较结果进行转移的条件转移指令。 [](marginnote3app://note/3FAE5729-75E6-45CB-9B79-38F0C619804A)
        - 11.10 DF标志和串传送指令 [](marginnote3app://note/1C4C92C6-F1FB-40AB-A5CF-20720794C7F2)
            - movsb [](marginnote3app://note/A8E18208-0B90-478C-9424-566048B55651)
            - movsw [](marginnote3app://note/9DE9FAE0-3E53-4281-BCB7-C23C34817493)
            - 串传送 [](marginnote3app://note/2D682215-BF79-432F-A3B9-BCF775850B16)
            - rep [](marginnote3app://note/F55D644E-DE31-4B13-9E1B-6CC344BC9B9B)
            - cld;std [](marginnote3app://note/2888EA08-DB1A-48BD-BA51-F2BC1A22E946)
        - 11.11 pushfz和popf [](marginnote3app://note/3AB47A70-EBC6-47A1-8CA4-3722AE5BC84E)
        - pushf的功能是将标志寄存器的值压栈，而popf是从栈中弹出数据，送入标志寄存器中。 [](marginnote3app://note/32EC7736-E79D-449F-800F-208ECFA85BD9)
        - pushf和popf,为直接访问标志寄存器提供了一种方法。 [](marginnote3app://note/332E9D56-9D89-488D-BFCB-0BDAD39AEE7C)
        - 11.12 标志寄存器在Debug中的表示 [](marginnote3app://note/A8BC25C4-DCEF-4837-A4A3-549FC3DAD42F)
            - AX=0000 BX=0000 CX=0000 DX=0000 SP=FFEE BP=0000 SI=0000 DI=0000 DS=★*** ES=****SS=★★ C**S=****IP=0100 NV UP EI PL NZ NA PO NC ↑↑↑↑↑↑OF DE SF ZF PF CE 下面列出Debug对我们已知的标志位的表示。 标志值为1的标记值为0的标记of OV NV sf NG PL zf ZR NZ PE cf df DN [](marginnote3app://note/F30483CA-9ECA-433F-AEA3-DA118ACE4ACB)
    - 第12章内中断 [](marginnote3app://note/96FAD31A-4AB0-42BA-92AA-1A824D0AB1E5)
        - 中断信息 [](marginnote3app://note/7654434F-3D93-4A64-86BE-28C25FB74B54)
        - 中断 [](marginnote3app://note/4A0D1C28-1054-4766-BA5C-CD6190768CAC)
        - 12.1 内中断的产生 [](marginnote3app://note/4CF76EEE-8BBE-4AB0-B00F-DFBC7792EA71)
            - (1) 除法错误，比如，执行div指令产生的除法溢出；  (2) 单步执行；  (3) 执行into指令；  (4) 执行int指令。 [](marginnote3app://note/6D578B4D-BE9C-41EA-800B-DCFF36596C48)
            - 8086CPU用称为中断类型码的数据来标识中断信息的来源。中断类型码为一个字节型数据，可以表示256种中断信息的来源。 [](marginnote3app://note/086FBFFE-5F26-4F7D-BB4E-73D05159A6FF)
            - 中断信息的事件，即中断信息的来源，简称为中断源， [](marginnote3app://note/67E433C3-30B3-4C31-8969-014D0AA0270F)
            - (1)除法错误：0 (2)单步执行：1 [](marginnote3app://note/C2EFD906-A986-4F1A-88AC-2DE3BFFC6831)
        - 12.3中断向量表 [](marginnote3app://note/03A30B9A-8521-4E02-B556-44312470400D)
            - 中断向量表，就是中断处理程序入口地址的列表。 [](marginnote3app://note/E53B0982-B336-4BCC-958B-3292063937BC)
            - 中断向量表在内存中保存，其中存放着256个中断源所 [](marginnote3app://note/E5944935-F4E6-40B5-A581-05B8DD279F6E)
            - ,如果使用8086CPU,中断向量表就必须放在0000：00000000：03FF单元中，这是规定，因为8086CPU就从这个地方读取中断向量表。 [](marginnote3app://note/50DE1307-027B-41F8-886D-BB5EAD337951)
            - 所以一个表项占两个字，高地址字存放段地址，低地址字存放偏移地址 [](marginnote3app://note/B967CCFB-0389-46D1-BAF8-8ACD4C8A282C)
        - 12.4中断过程 [](marginnote3app://note/4B179DAA-FC53-49E7-BA1C-25C54FA1FB8B)
            - CPU在执行完中断处理程序后，应该返回原来的执行点继续执行下面的指令。所以在中断过程中，在设置CS:P之前，还要将原来的CS和P的值保存起来。 [](marginnote3app://note/D06D5D2F-B91C-4B00-827C-66782DD812A5)
            - (1)(从中断信息中)取得中断类型码：  (2) 标志寄存器的值入栈（因为在中断过程中要改变标志寄存器的值，所以先将其保存在栈中)：  (3) 设置标志寄存器的第8位T℉和第9位F的值为0（这一步的目的后面将介绍）：  (4) CS的内容入栈； [](marginnote3app://note/CEE646E1-9A39-4A6A-8A7E-F496EF657D4D)
            - (5) IP 的内容入栈：  (6)从内存地址为中断类型码*4和中断类型码*4+2的两个字单元中读取中断处理程序的入口地址设置P和CS。 [](marginnote3app://note/5E1068AD-1062-4349-AA4B-1231B48FDEB9)
            - 我们更简洁地描述中断过程，如下：  (1) 取得中断类型码N;  (2) pushf  (3) TF=0,  (4) push CS  (5) push IP  (6) (IP)=N*4),(CS)=N*4+2)  在最后一步完成后，CPU开始执行由程序员编写的中断处理程序。 [](marginnote3app://note/FBCD2A7E-EAB6-42D4-9C38-F5FDBA280222)
        - 12.5中断处理程序和iret指令 [](marginnote3app://note/FC6C19F3-4004-44F6-B4BC-3BE07081DACD)
        - 12.6 除法错误中断的处理 [](marginnote3app://note/82172C57-6CFC-4FC4-9CB2-E47BED879C01)
            - 当CPU执行div bh时，发生了除法溢出错误，产生0号中断信息，从而引发中断过程，CPU执行0号中断处理程序。 [](marginnote3app://note/AAFF74B8-669F-466B-8B2F-F0DAC89D2A58)
        - 12.7 编程处理0号中断 [](marginnote3app://note/34174134-CA4F-4AE0-955C-A1BF4338A3DA)
            - 般情况下，从0000：0200至0000：02F℉的256个字节的空间所对应的中断向量表项都是空的，操作系统和其他应用程序都不占用。 [](marginnote3app://note/F3C79C30-88F0-43D2-AF32-207538255DB2)
            - 程序12.1中设置中断向量表的代码执行完后，在0号表项中填入了do0的入口地址0：200，此时0：200处的信息，即do0的代码，就变成了0号中断的中断处理程序。 因为当除法溢出（即0号中断）发生时，CPU将执行0：200处的代码。 [](marginnote3app://note/4A125490-78A3-4D91-8196-08EDEC0FC765)
        - 12.8安装 [](marginnote3app://note/8213AEB4-AC35-4BCC-8174-68A8ED2478AA)
            - 可以使用movsb指令，将do0的代码送入0：200处。程序如下。 assume cs:code code segment start:设置es:di指向目的地址设置ds:si指向源地址设置cx为传输长度设置传输方向为正rep movsb 设置中断向量表mov ax,4c00h int 21h do0:显示字符串"overf1ow!" mov ax,4c00h int 21h code ends end start [](marginnote3app://note/1C82FE60-5783-4ACA-B323-8750718EC0B8)
            - 对于用offset do0end-offset do(0,得到do0代码的长度 [](marginnote3app://note/C0A66223-3613-495D-995A-9D34736448D9)
        - 12.9do0 [](marginnote3app://note/75916963-78BF-4778-B903-14C59A8655E6)
            - 因为在do0程序开始处的“overflow!”不是可以执行的代码，所以在“overflow!”之前加上一条jmp指令，转移到正式的do0程序。当除法溢出发生时， CPU执行0：200处的jmp指令，跳过后面的字符串，转到正式的do0程序执行。 [](marginnote3app://note/6DAD32E3-C8B3-4CE9-98A2-C78A4FB95E46)
        - 12.10 设置中断向量 [](marginnote3app://note/B5A0F7A5-32D2-4B96-A201-091F1CF4ABC9)
        - 12.11单步中断 [](marginnote3app://note/EFF42D27-74FB-425F-8912-7949941DD229)
            - (1) 取得中断类型码1； (2) 标志寄存器入栈，T℉、F设置为0： (3) CS、P入栈： (4) (IP)=(1*4),(CS)=(1*4+2)。 [](marginnote3app://note/AB4D8A1A-37B8-4B5C-9F9D-655F8B180B1C)
            - 然后，在使用t命令执行指令时，Debug将TF设置为1，使得CPU工作于单步 [](marginnote3app://note/553C1141-54EA-49D7-AB19-4C7336567794)
            - 中断方式下，则在CPU执行完这条指令后就引发单步中断，执行单步中断的序，所有寄存器中的内容被显示在屏幕上，并且等待输入命令。 [](marginnote3app://note/34051027-CC71-46A0-9AF4-28A06AFCA58A)
            - 在进入中断处理程序之前，设置T℉-O。从而避免CPU在执行中断处理程序的时候发生单步中断。这就是为什么在中断过程中有TF=0这个步骤，我们再来看一下中断过程。 [](marginnote3app://note/70B208A2-5287-4A0B-BF03-54D606EADF23)
        - 12.12 响应中断的特殊情况 [](marginnote3app://note/CF2F9026-7C6C-4633-BD34-24E57DA3F317)
            - 在执行完向ss寄存器传送数据的指令后，即便是发生中断，CPU也不会响应。这样做的主要原因是，$s:Sp联合指向栈顶，而对它们的设置应该连续完成。如果在执行完设置ss的指令后，CPU响应中断，引发中断过程，要在栈中压入标志寄存器、CS和P的值。而ss改变，sp并未改变，sssp指向的不是正确的栈顶，将引起错误。所以CPU在执行完设置ss的指令后，不响应中断。这给连续设置ss和sp指向正确的栈顶提供了一个时机。 [](marginnote3app://note/B09D22F2-91C9-41EE-BDBC-31119C69B634)
            - 而在mov ss,ax指令执行后，CPU根本就不响应任何中断，其中也包括单步中断，所以Dbug设置好的用来显示寄存器状态和等待输入命令的中断处理程序根本没有得到执行，所以我们看不到预期的结果。CPU接着向下执行后面的指令ov sp,10h,然后响应单步中断，我们才看到正常的结果。 [](marginnote3app://note/E02E038B-F890-4ACB-8696-B54B837016CE)
        - 实验12 编写0号中断的处理程序 [](marginnote3app://note/1BA00890-47E8-4235-8AE4-98BA656C1120)
    - 第13章int指令 [](marginnote3app://note/DB2B6081-E623-4FAE-8690-72865CBF2C4C)
        - 13.1int指令 [](marginnote3app://note/DB992020-9C7E-48C3-8415-F0EF139DC9BC)
            - (1) 取中断类型码n; (2) 标志寄存器入栈，F=0, TF=0: (3) CS、P入栈； (4) (IP)=(n*4),(CS)=(n*4+2). [](marginnote3app://note/00CCB9F5-3A06-44E8-B2AC-A5BE6BA3767A)
        - 13.2 编写供应用程序调用的中断例程 [](marginnote3app://note/81E2C2F6-01E1-4404-8E2F-800F8E0EBFAB)
            - 避免寄存器的冲突。应该注意例程中用到的寄存器的值的保存和恢复。 [](marginnote3app://note/08E5CB3C-6090-4E7C-8E31-59E30ACBCEA5)
        - 13.3 对int、iret和栈的深入理解 [](marginnote3app://note/C9F6E58A-69BF-4110-8F6B-C529FEC2C41C)
            - 7ch中断例程如下。 lp:push bp mov bp,sp 6死战中.邮dec cx jcxz pret将闭于返0麻伤位add ([bp+21),bx lpret:pop bp 收苏存号5处的iret [](marginnote3app://note/18EEF08E-C154-485D-85DD-C4C63799745A)
            - 可以利用iret指令，我们将栈中的se的偏移地址加上bx中的转移位移，则栈中的se 的偏移地址就变为了s的偏移地址。我们再使用it指令，用栈中的内容设置CS、IP,从而实现转移到标号s处。 [](marginnote3app://note/28A615E3-CA59-49CA-A7EE-ACAE9298AB3B)
        - 检测点13.1 [](marginnote3app://note/5C39377D-3F9A-4F3A-B241-8D03E3ACC672)
        - 13.5 B1OS和DOS中断例程的安装过程 [](marginnote3app://note/6F2EDC0D-DE54-41DD-B8F0-6E486A5A90F4)
        - 13.6 BIOS中断例程应用 [](marginnote3app://note/800649C5-2D4B-46DB-A4C4-5770AC077F3A)
        - 13.7 DOS中断例程应用 [](marginnote3app://note/698B0750-1A75-4338-9891-6ED9654D397A)
        - 实验13 编写、应用中断例程 [](marginnote3app://note/266636FF-83E5-487B-AE23-B95D9A5559F9)
            - (1) 编写并安装it7ch中断例程，功能为显示一个用0结束的字符串，中断例程安装在0：200处。 参数：(dh)=行号，(d)=列号，(cl)颜色，ds:si指向字符串首地址。 [](marginnote3app://note/63B2EB3D-19D1-4183-8C83-43F7DF6D3A43)
            - (2 编写并安装int7ch中断例程， 功能为完成loop指令的功能参数：(cx)=循环次数，(bx)=位移 [](marginnote3app://note/767AF20A-F7FD-42A4-8E05-B164E85CCB2B)
            - (3)下面的程序，分别在屏幕的第2、4、6、8行显示4句英文诗，补全程序。 [](marginnote3app://note/C3A475DD-46DA-4D63-A578-C5BB5A6AA46F)
    - 第14章端口 [](marginnote3app://note/AC97F15C-1537-460D-A33E-F839EF7BC17D)
        - 14.1端口的读写 [](marginnote3app://note/9A4C7042-03BA-4460-96E8-237F8D2208F3)
            - (2)访问端口： [](marginnote3app://note/E41FA980-0529-444E-88EF-8DFDCA48B7CA)
        - 14.2 CMOS RAM芯片 [](marginnote3app://note/D61EBAB5-A2B5-4F4A-8FF6-2189F0F62061)
            - 128个字节的RAM中，内部实时钟占用**00dh**单元来**保存时间信息**，其余大部分单元用于保存系统配置信息，供系统启动时BIOS程序读取。 [](marginnote3app://note/C6A56795-5F65-48B0-863B-D7BE7BD9F193)
            - (4) 该芯片内部有两个端口，端口地址为70h和71h。CPU通过这两个端口来读写CMOS RAM [](marginnote3app://note/6D31894E-3935-4277-AF85-0C790D866F9E)
            - (5)70h为地址端口，存放要访问的CMOS RAM单元的地址；71h为数据端口，存放从选定的CMOS RAM单元中读取的数据，或要写入到其中的数据。可见，CPU对CMOS RAM的读写分两步进行，比如，读CMOS RAM的2号单元： [](marginnote3app://note/E60D5FD0-C97A-4A01-8D0D-4DBF37FF1877)
        - 14.3 shl和shr指令 [](marginnote3app://note/406D4A5E-56DC-4032-928A-518A677E73EB)
            - sl是逻辑左移指令，它的功能为： (1) 将一个寄存器或内存单元中的数据向左移位； (2) 将最后移出的一位写入CF中： (3) 最低位用0补充。 [](marginnote3app://note/8EE0DB8B-3890-47CA-A84C-5FA0FE38E55A)
            - 如果移动位数大于1时，必须将移动位数放在c1中。 [](marginnote3app://note/CA7F8D96-E82A-4CEB-874C-89D26B70B6E2)
        - 14.4 CMOS RAM中存储的时间信息 [](marginnote3app://note/501D20C3-59EB-4A53-8389-2A6C033BB71B)
            - BCD码 [](marginnote3app://note/651B2611-DA02-4EFE-AC9D-66D7D8AE86CE)
        - 实验14访问CMOS RAM [](marginnote3app://note/AD906D5D-AA0C-4F2F-BA63-81591CD3D1A2)
    - 第15章外中断 [](marginnote3app://note/EC5CE6D4-6AC8-427E-80AA-C75AB91508E0)
        - 15.1接口芯片和端口 [](marginnote3app://note/B3A07635-C261-41F7-AE8E-D4974739FD85)
        - 15.2外中断信息 [](marginnote3app://note/60F4BD27-0A56-43C9-9F22-6842A77279AF)
            - 1.可屏蔽中断 [](marginnote3app://note/D905D594-1C61-4D57-AFB8-277596644424)
                - (1) 取中断类型码n; (2) 标志寄存器入栈，F=0,TF=0; (3) CS、P入栈： (4) (IP)=(n*4),(CS)=(n*4+2) [](marginnote3app://note/D33AD555-D16D-4182-9FF8-2776A1E98526)
                - cli i餐枚中做，正-定机行 **sti**,**设置IF=1**;moy word p r(5:[7H4],7E00H;i置中向多兵 **cli**,**设置F=0**。mov word p竹S:CcW+2],0 [](marginnote3app://note/D3E6111E-5A8E-4A25-A3CB-DB2AFA8656FB)
            - 2.不可屏蔽中断 [](marginnote3app://note/82643CB7-7517-4DB0-A496-F17408CCAFF6)
            - 不可屏蔽中断的中断类型码固定为2，所以中断过程中，不需要取中断类型码。则不可屏蔽中断的中断过程为： [](marginnote3app://note/0983E2D8-E4D1-4A17-88EC-7BC2D7C854E2)
        - 15.3 PC机键盘的处理过程 [](marginnote3app://note/79BF3F38-544B-4930-8F73-0AD27D304F06)
            - 1.键盘输入 [](marginnote3app://note/627D3D81-7D90-42F5-9A52-D09BFF65417C)
            - 断码=通码+80h [](marginnote3app://note/73A2F29B-ED51-4DE7-B5A7-96BB6935EA31)
            - 2.引发9号中断 [](marginnote3app://note/FF5A30D5-F281-4BFE-9B52-EC3354198127)
        - 3.执行int9中断例程 [](marginnote3app://note/0D8D140A-036C-4F47-87D5-7B382FF2652A)
            - 是字符键的扫描码，将该扫描码和它所对应的字符码（即ASCⅡ码）送入内存中的BIOS 键盘缓冲区；如果是控制键（比如Ctrl)和切换键（比如CapsLock)的扫描码，则将其转变为状态字节（用二进制位记录控制键和切换键状态的字节）写入内存中存储状态字节的单元； [](marginnote3app://note/FE55F762-C148-4AC5-B182-F7B8AC245BE4)
            - 0040:17单元存储键盘状态字节，该字节记录了控制键和切换键的状态。键盘状态字节各位记录的信息如下。 [](marginnote3app://note/5C6E1350-867E-436A-9534-A65B59C279CB)
            - 该内存区可以存储15个键盘输入，因为it9中断例程除了接收扫描码外，还要产生和扫描码对应的字符码，所以在BIOS键盘缓冲区 [](marginnote3app://note/68B29452-37F0-4DCD-AB82-A811A41E1B72)
        - 实验15安装新的int9中断例程 [](marginnote3app://note/7DA6D87D-DB87-4301-AD0A-96EF789AEF41)
    - 第16章直接定址表 [](marginnote3app://note/FD02ED58-DFE6-4932-B1D7-09934C501969)
        - 16.1描述了单元长度的标号 [](marginnote3app://note/432DE53A-C876-41A1-A728-FDC4583A69C3)
            - 我们还可以使用一种标号，这种标号不但表示内存单元的地址，还表示了内存单元的长度，即表示在此标号处的单元，是一个字节单元，还是字单元，还是双字单元。 [](marginnote3app://note/ECBC2AA5-C62D-44CF-8C9A-EB32BE7852F7)
            - 这种包含单元长度的标号，可以使我们以简洁的形式访问内存中的数据。 以后，我们将这种标号称为数据标号，它标记了存储数据的单元的地址和长度。 [](marginnote3app://note/B1416BA3-3D0D-4293-B719-EDA65B94A10A)
        - 16.2在其他段中使用数据标号 [](marginnote3app://note/31B00D59-E80D-463D-8B1C-D49A9162DE8A)
            - 我们要在代码段 code 中用 Ah 段中的数据标号 a、 b 访问数 ig, 则必须用 assume 将一个寄存器和 data 段相联, 在程序中, 我们用 da 寄存器和 data 段相联, [](marginnote3app://note/B024442D-64D9-4DBF-9568-6668581AF3A0)
        - 16.3 直接定址表 [](marginnote3app://note/BBD6854C-A8FD-4508-8FF5-B4A60B7BAEC2)
            - 利用表，在两个数据集合之间建立一种映射关系，使我们可以用查表的方法根据给出的数据得到其在另一集合中的对应数据。这样做的目的一般来说有以下 3 个。 [](marginnote3app://note/01FB2BC8-2BF4-495D-AEFB-0AB38714BB6D)
        - 16.4 程序入口地址的直接定址表 [](marginnote3app://note/4B7AF508-F44A-40C4-938E-D7772620D9C6)
            - 我们可以将这些功能子程序的入口地址存储在一个表中，它们在表中的位置和功能号相对应。对应关系为：功能号*2=对应的功能子程序在地址表中的偏移。 [](marginnote3app://note/347FD1A7-D31D-4459-90D2-A264AFC49950)
    - 第 17 章使用 BIOS 进行键盘输入和磁盘读写 [](marginnote3app://note/F321DE1B-B186-4DF1-B33F-64C257A6E381)
        - 17.1 int9中断例程对键盘输入的处理 [](marginnote3app://note/6B1B32ED-11A3-42BC-9AD5-07B2C944DCB9)
            - BIOS的int9中断例程和int16h中断例程是一对相互配合的程序，int9中断例程向键盘缓冲区中写入，it16h中断例程从缓冲区中读出。它们写入和读出的时机不同，int9中断例程是在有键按下的时候向键盘缓冲区中写入数据；而it16h中断例程是在应用程序对其进行调用的时候，将数据从键盘缓冲区中读出。 [](marginnote3app://note/CD1FDB1B-A75E-41C0-A527-BCCE2A7297C0)
        - 17.3 字符串的输入 [](marginnote3app://note/65B6D3E4-2531-46EC-8044-E308BB36318E)
        - 17.4 应用 int13h 中断例程对磁盘进行读写 [](marginnote3app://note/F1CAF398-FA98-44E5-B7FC-F1B941440644)
        - 课程设计2 [](marginnote3app://note/BB066822-6F47-4A6F-B049-544976C4C3D4)
    - 附注5公式证明 [](marginnote3app://note/E5A8F0B9-97A4-406B-8A69-D359D5D94DD4)
    - 拓展 [](marginnote3app://note/CAC443A3-EC63-4813-98BC-411C958A1C35)
        - 实模式 [](marginnote3app://note/D698DCC3-214F-4B87-B530-84434F74BE71)
        - 保护模式 [](marginnote3app://note/E25509F3-FF82-4595-A297-54DF28ECEE3D)